.combine = rbind,
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here")
) %dopar% {
set.seed(seeds[j])
# Generates simulated data
simdata <- gen_data(n = params$n,
beta_true = params$beta_true,
err_type = params$err_type
)
# try to restructure this so that i get the bootstrapped data stuff here
# Computes Estimates
# Note each: each result is one (1) single row
model_fit <- fit_model(simdata)
wald_result <- extract_estims(model = model_fit,
beta_true = params$beta_true,
alpha = alpha)
wald_result <- cbind(wald_result, scenario = i, sim = j, params)
# Computes Bootstrap Percentile estimates
nboot <- 50
boot_data <- get_boot_data(original_data = simdata,
beta_true = params$beta_true,
sample_size = params$n,
nboot = nboot,
alpha = alpha)
boot_percent_result <- extract_estim_boot_percent(all_boot_betas = boot_data,
beta_true = params$beta_true,
alpha = alpha)
boot_percent_result <- cbind(boot_percent_result, scenario = i, sim = j, params)
# Boot t estimates
#boot_t_result <- extract_estim_boot_t(data = simdata,
#                                                  beta_true = params$beta_true,
#                                                  alpha = alpha)
#boot_t_result <- cbind(boot_t_result, scenario = i, sim = j, params)
# Casts 2 rows into 2 lists and makes 2 columns, 1 for each list
tibble(
wald = list(wald_result),
boot_percent = list(boot_percent_result),
sim_data = list(simdata)
#boot_t = list(boot_t_result)
)
}
# Turns each row in wald column into dataframe and binds all rows together for all 475 wald results for current
#simulation
all_wald_estim <- bind_rows(lapply(sim_results$wald, as.data.frame))
all_boot_percent_estim <- bind_rows(lapply(sim_results$boot_percent, as.data.frame))
all_sim_data <- bind_rows(lapply(sim_results$sim_data, as.data.frame))
#all_boot_t_estim <- bind_rows(lapply(sim_results$boot_t, as.data.frame))
# Save **only** the single scenarioâ€™s results, not the full list!
save(all_wald_estim, file = here("results", "sim_wald", paste0("scenario_", i, ".RDA")))
save(all_boot_percent_estim, file = here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA")))
save(all_sim_data, file = here("results", "sim_data", paste0("scenario_", i, ".RDA")))
#save(all_boot_t_estim, file = here("results", "sim_boot_t", paste0("scenario_", i, ".RDA")))
# Print progress
cat(sprintf("Saved scenario %d (n = %d, beta_true = %.2f, err_type = %d)\n",
i, params$n, params$beta_true, params$err_type))
}
# Stop the cluster
stopCluster(cl)
library(dplyr)
# Define the number of scenarios
# only first 8 done for boot_t
num_scenarios <- 18
# Initialize an empty data frame to store results
coverage_results <- data.frame(
scenario = integer(),
coverage_percentage = numeric()
)
# Loop through each scenario file
for (i in 1:num_scenarios) {
file_path <- here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA"))
load(file_path)
# Calculates the coverage percentage
all_ones <- all_boot_percent_estim %>% filter(coverage == 1)
coverage_percentage <- (nrow(all_ones) / 475) * 100
coverage_results <- rbind(
coverage_results,
data.frame(scenario = i, coverage_percentage = coverage_percentage)
)
}
print(coverage_results)
View(param_grid)
library(tidyverse)
library(doParallel)
library(foreach)
gen_data <- function(n, beta_true, err_type) {
beta0 <- 1
beta_treat <- beta_true
x <- rbinom(n, 1, prob = 0.5)
while (length(unique(x)) == 1) {
x <- rbinom(n, 1, prob = 0.5)
}
epsilon <- rep(NA, n)
if (err_type == 1) {
epsilon <- rnorm(n, mean = 0, sd = sqrt(2))
} else {
epsilon <- rlnorm(n, mean = 0, sd = sqrt(log(2)))
}
y = beta0 + beta_treat * x + epsilon
tibble(
x = x,
y = y,
)
}
fit_model <- function(data) {
model <- lm(y ~ x, data = data)
return (model)
}
extract_estims <- function(model, beta_true, alpha) {
estims_df <- tidy(model, conf.int = TRUE) %>%
filter(term == "x") %>%
rename(beta_hat = estimate) %>%
rename(se_beta = std.error) %>%
mutate(beta_diff = beta_hat - beta_true) %>%
mutate(coverage = ifelse(beta_true >= conf.low & beta_true <= conf.high, 1, 0)) %>%
select(beta_hat, beta_diff, se_beta, coverage)
return (estims_df)
}
# We are given a df of x and y with n rows (for each iteration of the 475 n_sims)
extract_estim_boot_percent <- function(all_boot_betas, beta_true, alpha) {
# Compute summary statistics
mean_beta_hat <- mean(all_boot_betas, na.rm = TRUE)  # Mean of bootstrap estimates
# Percentile confidence interval
percentile_ci <- quantile(all_boot_betas, probs = c(alpha/2, 1 - (alpha/2)), na.rm = TRUE)
boot_percent_df <- tibble(
mean_beta_hat = mean_beta_hat,
ci_l = percentile_ci[1],
ci_u = percentile_ci[2]
)
boot_percent_df <- boot_percent_df %>%
mutate(coverage = ifelse(!is.na(ci_l) & !is.na(ci_u) & beta_true >= ci_l & beta_true <= ci_u, 1, 0))
return(boot_percent_df)
}
get_boot_data <- function (original_data, beta_true, sample_size, alpha, nboot) {
all_boot_betas <- rep(NA, nboot)
for (i in 1:nboot) {
# Non-parametric bootstrap sample
rows <- sample(1:sample_size, sample_size, replace = TRUE)
boot_sample <- original_data[rows,]
boot_sample_model <- fit_model(data = boot_sample)
# Extract beta_treatment
model_estims <- extract_estims(boot_sample_model, beta_true, alpha)
all_boot_betas[i] <- ifelse(nrow(model_estims) == 1, model_estims$beta_hat, NA)
}
return (all_boot_betas)
}
# We are given a df of x and y with n rows (for each iteration of the 475 n_sims)
extract_estim_boot_t <- function(data, beta_true, alpha) {
original_model_estims <- extract_estims(data, beta_true, alpha)
beta_hat <- original_model_estims$beta_hat
nboot <- 50  # Number of bootstrap samples
nboot_t <- 10 # Inner loop to calculate t star
all_boot_betas <- rep(NA, nboot)  # change to rep NA first
all_nested_boot_betas <- rep(NA, nboot_t)
t_star <- rep(NA, nboot_t)
for (i in 1:nboot) {
# Non-parametric bootstrap sample
boot_sample <- slice_sample(data, n = nrow(data), replace = TRUE)
# Fit linear model and extract beta_treatment
first_model_estims <- extract_estims(data = boot_sample,
beta_true = beta_true,
alpha = alpha)
# Return the estimate or NA if invalid
all_boot_betas[i] <- ifelse(nrow(first_model_estims) == 1, first_model_estims$beta_hat, NA)
for (j in 1:nboot_t) {
nested_boot_sample <- slice_sample(boot_sample, n = nrow(boot_sample), replace = TRUE)
nested_model_estims <- extract_estims(data = nested_boot_sample,
beta_true = beta_true,
alpha = alpha)
all_nested_boot_betas[j] <- ifelse(nrow(nested_model_estims) == 1, nested_model_estims$beta_hat, NA)
}
se_star = sd(all_nested_boot_betas,  na.rm = TRUE) # is this right... idk
if (any(is.na(c(all_boot_betas[i], beta_hat, se_star)))) {
t_star[i] <- NA
} else {
t_star[i] <- (all_boot_betas[i] - beta_hat) / se_star
}
}
# Compute summary statistics
mean_beta_hat <- mean(all_boot_betas, na.rm = TRUE)  # Mean of bootstrap estimates
# Percentile confidence interval
percentile_ci <- quantile(all_boot_betas, probs = c(alpha / 2, 1 - alpha / 2), na.rm = TRUE)
# quantile CI for bootstrap t
t_quants = quantile(t_star, probs = c(alpha/2, 1-(alpha/2)),  na.rm = TRUE)
se_beta_hat = sd(all_boot_betas)
# lower CI
boot_t_ci_l <- beta_hat - t_quants[2] * se_beta_hat
# upper CI
boot_t_ci_u <- beta_hat - t_quants[1] * se_beta_hat
boot_t_df <- tibble(
mean_beta_hat = mean_beta_hat,
se_beta_hat = se_beta_hat, # same as the percentile t method
percent_ci_l = percentile_ci[1],
percent_ci_u = percentile_ci[2],
t_ci_l = boot_t_ci_l, #calculated froim ses of the nested bootstrap
t_ci_u = boot_t_ci_u,
)
boot_t_df <- boot_t_df %>%
mutate(coverage = ifelse(!is.na(percent_ci_l) & !is.na(percent_ci_u) & beta_true >= percent_ci_l & beta_true <= percent_ci_u, 1, 0)) %>%
mutate(t_coverage = ifelse(!is.na(t_ci_l) & !is.na(t_ci_u) & beta_true >= t_ci_l & beta_true <= t_ci_u, 1, 0))
return(boot_t_df)
}
library(tidyverse)
library(doParallel)
library(foreach)
library(dplyr)
library(here)
source(here("source", "utils.R"))
options(pillar.sigfig = 15)
# Makes sure directories exist
if (!dir.exists(here("results"))) {
dir.create(here("results"))
}
if (!dir.exists(here("results", "sim_wald"))) {
dir.create(here("results", "sim_wald"))
}
if (!dir.exists(here("results", "sim_boot_percentile"))) {
dir.create(here("results", "sim_boot_percentile"))
}
if (!dir.exists(here("results", "sim_boot_t"))) {
dir.create(here("results", "sim_boot_t"))
}
# Cluster setup
cl <- makeCluster(12)  # Use 12 cores
registerDoParallel(cl)
# Simulation setup
mc_err <- 0.01
cover <- 0.95
alpha <- 1 - 0.95
n_sim <- round((cover * (1 - cover)) / mc_err^2)
n <- c(10, 50, 500)
beta_true <- c(0, 0.5, 2)
err_type <- c(0, 1)  # 1 = normal, 0 = lognormal
param_grid <- expand.grid(
n = n,
beta_true = beta_true,
err_type = err_type
)
# Seeds!
set.seed(3000)
seeds <- floor(runif(n_sim, 1, 10000))
# Iterates through 18 parameter combinations
for (i in 1:nrow(param_grid)) {
params <- param_grid[i, ]
# Runs 475 simulations per parameter combo
# Overall structure goal:  18 data frames x 475 rows for each method (Wald/percentile/t)
# sim_results structure: dataframe with 475 rows, and 2 columns, each column is a list form of a
# dataframe for specified method, i.e. sim_results$wald and sim_results$boot each have 475 rows, with each 1 row
# having info abt the estimated beta_hat, std error, confidence interval, etc. for that specific simulation run
# Each simulation run adds another row to the dataframe.
# At the end of all 475 simulations for the current scenario, I can just convert every row
# of sim_results to 1-row dataframes and bind them to their corresponding method (Wald/percentile/etc.) dataframe
# End result:
# all_wald_estim = 1 dataframe, 475 rows
sim_results <- foreach(
j = 1:n_sim,
.combine = rbind,
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here")
) %dopar% {
set.seed(seeds[j])
# Generates simulated data
simdata <- gen_data(n = params$n,
beta_true = params$beta_true,
err_type = params$err_type
)
# try to restructure this so that i get the bootstrapped data stuff here
# Computes Estimates
# Note each: each result is one (1) single row
model_fit <- fit_model(simdata)
wald_result <- extract_estims(model = model_fit,
beta_true = params$beta_true,
alpha = alpha)
wald_result <- cbind(wald_result, scenario = i, sim = j, params)
# Computes Bootstrap Percentile estimates
nboot <- 50
boot_data <- get_boot_data(original_data = simdata,
beta_true = params$beta_true,
sample_size = params$n,
nboot = nboot,
alpha = alpha)
boot_percent_result <- extract_estim_boot_percent(all_boot_betas = boot_data,
beta_true = params$beta_true,
alpha = alpha)
boot_percent_result <- cbind(boot_percent_result, scenario = i, sim = j, params)
# Boot t estimates
#boot_t_result <- extract_estim_boot_t(data = simdata,
#                                                  beta_true = params$beta_true,
#                                                  alpha = alpha)
#boot_t_result <- cbind(boot_t_result, scenario = i, sim = j, params)
# Casts 2 rows into 2 lists and makes 2 columns, 1 for each list
tibble(
wald = list(wald_result),
boot_percent = list(boot_percent_result),
sim_data = list(simdata)
#boot_t = list(boot_t_result)
)
}
# Turns each row in wald column into dataframe and binds all rows together for all 475 wald results for current
#simulation
all_wald_estim <- bind_rows(lapply(sim_results$wald, as.data.frame))
all_boot_percent_estim <- bind_rows(lapply(sim_results$boot_percent, as.data.frame))
all_sim_data <- bind_rows(lapply(sim_results$sim_data, as.data.frame))
#all_boot_t_estim <- bind_rows(lapply(sim_results$boot_t, as.data.frame))
# Save **only** the single scenarioâ€™s results, not the full list!
save(all_wald_estim, file = here("results", "sim_wald", paste0("scenario_", i, ".RDA")))
save(all_boot_percent_estim, file = here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA")))
save(all_sim_data, file = here("results", "sim_data", paste0("scenario_", i, ".RDA")))
#save(all_boot_t_estim, file = here("results", "sim_boot_t", paste0("scenario_", i, ".RDA")))
# Print progress
cat(sprintf("Saved scenario %d (n = %d, beta_true = %.2f, err_type = %d)\n",
i, params$n, params$beta_true, params$err_type))
}
library(dplyr)
# Define the number of scenarios
# only first 8 done for boot_t
num_scenarios <- 1
# Initialize an empty data frame to store results
coverage_results <- data.frame(
scenario = integer(),
coverage_percentage = numeric()
)
# Loop through each scenario file
for (i in 1:num_scenarios) {
file_path <- here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA"))
load(file_path)
# Calculates the coverage percentage
all_ones <- all_boot_percent_estim %>% filter(coverage == 1)
coverage_percentage <- (nrow(all_ones) / 475) * 100
coverage_results <- rbind(
coverage_results,
data.frame(scenario = i, coverage_percentage = coverage_percentage)
)
}
print(coverage_results)
library(dplyr)
# Define the number of scenarios
# only first 8 done for boot_t
num_scenarios <- 3
# Initialize an empty data frame to store results
coverage_results <- data.frame(
scenario = integer(),
coverage_percentage = numeric()
)
# Loop through each scenario file
for (i in 1:num_scenarios) {
file_path <- here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA"))
load(file_path)
# Calculates the coverage percentage
all_ones <- all_boot_percent_estim %>% filter(coverage == 1)
coverage_percentage <- (nrow(all_ones) / 475) * 100
coverage_results <- rbind(
coverage_results,
data.frame(scenario = i, coverage_percentage = coverage_percentage)
)
}
print(coverage_results)
library(tidyverse)
library(doParallel)
library(foreach)
library(dplyr)
library(here)
source(here("source", "utils.R"))
options(pillar.sigfig = 15)
# Makes sure directories exist
if (!dir.exists(here("results"))) {
dir.create(here("results"))
}
if (!dir.exists(here("results", "sim_wald"))) {
dir.create(here("results", "sim_wald"))
}
if (!dir.exists(here("results", "sim_boot_percentile"))) {
dir.create(here("results", "sim_boot_percentile"))
}
if (!dir.exists(here("results", "sim_boot_t"))) {
dir.create(here("results", "sim_boot_t"))
}
# Cluster setup
cl <- makeCluster(12)  # Use 12 cores
registerDoParallel(cl)
# Simulation setup
mc_err <- 0.01
cover <- 0.95
alpha <- 1 - 0.95
n_sim <- round((cover * (1 - cover)) / mc_err^2)
n <- c(10, 50, 500)
beta_true <- c(0, 0.5, 2)
err_type <- c(0, 1)  # 1 = normal, 0 = lognormal
param_grid <- expand.grid(
n = n,
beta_true = beta_true,
err_type = err_type
)
# Seeds!
set.seed(3000)
seeds <- floor(runif(n_sim, 1, 10000))
# Iterates through 18 parameter combinations
for (i in 1:nrow(param_grid)) {
params <- param_grid[i, ]
# Runs 475 simulations per parameter combo
# Overall structure goal:  18 data frames x 475 rows for each method (Wald/percentile/t)
# sim_results structure: dataframe with 475 rows, and 2 columns, each column is a list form of a
# dataframe for specified method, i.e. sim_results$wald and sim_results$boot each have 475 rows, with each 1 row
# having info abt the estimated beta_hat, std error, confidence interval, etc. for that specific simulation run
# Each simulation run adds another row to the dataframe.
# At the end of all 475 simulations for the current scenario, I can just convert every row
# of sim_results to 1-row dataframes and bind them to their corresponding method (Wald/percentile/etc.) dataframe
# End result:
# all_wald_estim = 1 dataframe, 475 rows
sim_results <- foreach(
j = 1:n_sim,
.combine = rbind,
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here")
) %dopar% {
set.seed(seeds[j])
# Generates simulated data
simdata <- gen_data(n = params$n,
beta_true = params$beta_true,
err_type = params$err_type
)
# try to restructure this so that i get the bootstrapped data stuff here
# Computes Estimates
# Note each: each result is one (1) single row
model_fit <- fit_model(simdata)
wald_result <- extract_estims(model = model_fit,
beta_true = params$beta_true,
alpha = alpha)
wald_result <- cbind(wald_result, scenario = i, sim = j, params)
# Computes Bootstrap Percentile estimates
nboot <- 50
boot_data <- get_boot_data(original_data = simdata,
beta_true = params$beta_true,
sample_size = params$n,
nboot = nboot,
alpha = alpha)
boot_percent_result <- extract_estim_boot_percent(all_boot_betas = boot_data,
beta_true = params$beta_true,
alpha = alpha)
boot_percent_result <- cbind(boot_percent_result, scenario = i, sim = j, params)
# Boot t estimates
#boot_t_result <- extract_estim_boot_t(data = simdata,
#                                                  beta_true = params$beta_true,
#                                                  alpha = alpha)
#boot_t_result <- cbind(boot_t_result, scenario = i, sim = j, params)
# Casts 2 rows into 2 lists and makes 2 columns, 1 for each list
tibble(
wald = list(wald_result),
boot_percent = list(boot_percent_result),
sim_data = list(simdata)
#boot_t = list(boot_t_result)
)
}
# Turns each row in wald column into dataframe and binds all rows together for all 475 wald results for current
#simulation
all_wald_estim <- bind_rows(lapply(sim_results$wald, as.data.frame))
all_boot_percent_estim <- bind_rows(lapply(sim_results$boot_percent, as.data.frame))
all_sim_data <- bind_rows(lapply(sim_results$sim_data, as.data.frame))
#all_boot_t_estim <- bind_rows(lapply(sim_results$boot_t, as.data.frame))
# Save **only** the single scenarioâ€™s results, not the full list!
save(all_wald_estim, file = here("results", "sim_wald", paste0("scenario_", i, ".RDA")))
save(all_boot_percent_estim, file = here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA")))
save(all_sim_data, file = here("results", "sim_data", paste0("scenario_", i, ".RDA")))
#save(all_boot_t_estim, file = here("results", "sim_boot_t", paste0("scenario_", i, ".RDA")))
# Print progress
cat(sprintf("Saved scenario %d (n = %d, beta_true = %.2f, err_type = %d)\n",
i, params$n, params$beta_true, params$err_type))
}
# Stop the cluster
stopCluster(cl)
library(dplyr)
# Define the number of scenarios
# only first 8 done for boot_t
num_scenarios <- 18
# Initialize an empty data frame to store results
coverage_results <- data.frame(
scenario = integer(),
coverage_percentage = numeric()
)
# Loop through each scenario file
for (i in 1:num_scenarios) {
file_path <- here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA"))
load(file_path)
# Calculates the coverage percentage
all_ones <- all_boot_percent_estim %>% filter(coverage == 1)
coverage_percentage <- (nrow(all_ones) / 475) * 100
coverage_results <- rbind(
coverage_results,
data.frame(scenario = i, coverage_percentage = coverage_percentage)
)
}
print(coverage_results)
library(dplyr)
# Define the number of scenarios
# only first 8 done for boot_t
num_scenarios <- 18
# Initialize an empty data frame to store results
coverage_results <- data.frame(
scenario = integer(),
coverage_percentage = numeric()
)
# Loop through each scenario file
for (i in 1:num_scenarios) {
file_path <- here("results", "sim_wald", paste0("scenario_", i, ".RDA"))
load(file_path)
# Calculates the coverage percentage
all_ones <- all_wald_estim %>% filter(coverage == 1)
coverage_percentage <- (nrow(all_ones) / 475) * 100
coverage_results <- rbind(
coverage_results,
data.frame(scenario = i, coverage_percentage = coverage_percentage)
)
}
print(coverage_results)
View(param_grid)
