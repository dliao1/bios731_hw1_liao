dir.create(here("results", "sim_wald"))
}
if (!dir.exists(here("results", "sim_boot"))) {
dir.create(here("results", "sim_boot"))
}
# Cluster setup
cl <- makeCluster(4)  # Use 8 cores
registerDoParallel(cl)
# Simulation setup
mc_err <- 0.01
cover <- 0.95
alpha <- 1 - 0.95
n_sim <- round((cover * (1 - cover)) / mc_err^2)  # Calculate number of simulations
n <- c(10, 50, 500)
beta_true <- c(0, 0.5, 2)
err_type <- c(0, 1)  # 1 = normal, 0 = right-skewed
param_grid <- expand.grid(
n = n,
beta_true = beta_true,
err_type = err_type
)
# Seeds for each loop
seeds <- floor(runif(n_sim, 1, 10000))
# Parallelized Wald results
wald_results <- foreach(
i = 1:nrow(param_grid),
.combine = rbind,  # Combine results across parameter combinations
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %dopar% {
params <- param_grid[i, ]
# Run simulations for n_sim in parallel
all_wald_estim <- foreach(
j = 1:n_sim,
.combine = rbind,  # Combine results for each simulation
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %do% {
set.seed(seeds[j])
simdata <- gen_data(n = params$n, beta_true = params$beta_true, err_type = params$err_type)
extract_estim_wald(simdata, params$beta_true, alpha)
}
# Save individual parameter combination results
filename <- paste0("scenario_", i, ".RDA")
save(all_wald_estim, file = here("results", "sim_wald", filename))
return(all_wald_estim)
}
save(wald_results, file = here("results", "sim_wald", "all_sim_wald_scenarios.RDA"))
# Parallelized Bootstrap results
boot_results <- foreach(
i = 1:nrow(param_grid),
.combine = rbind,  # Combine results across parameter combinations
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %dopar% {
params <- param_grid[i, ]
# Run simulations for n_sim in parallel
all_boot_percent_estim <- foreach(
j = 1:n_sim,
.combine = rbind,  # Combine results for each simulation
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %do% {
set.seed(seeds[j])
simdata <- gen_data(n = params$n, beta_true = params$beta_true, err_type = params$err_type)
extract_estim_boot(simdata, params$beta_true, alpha)
}
# Save individual parameter combination results
filename <- paste0("scenario_", i, ".RDA")
save(all_boot_percent_estim, file = here("results", "sim_boot", filename))
return(all_boot_percent_estim)
}
library(tidyverse)
library(doParallel)
library(foreach)
gen_data <- function(n, beta_true, err_type) {
beta0 <- 1
beta_treat <- beta_true
x <- rbinom(n, 1, prob = 0.5)
epsilon <- ifelse (err_type == 1, rnorm(n, mean = 0, sd = sqrt(2)), rlnorm(n, mean = 0, sd = sqrt(log(2))))
y = beta0 + beta_treat * x + epsilon
tibble(
x = x,
y = y
)
}
extract_estim_wald <- function(simdata, beta_true, alpha) {
x <- simdata$x
y <- simdata$y
model <- summary(lm(y ~ x))
estims_df <- tidy(model, conf.int = TRUE) %>%
filter(term == "x") %>%
mutate(coverage = ifelse(beta_true >= conf.low & beta_true <= conf.high, 1, 0)) %>%
rename(beta_hat = estimate) %>%
rename(se_beta = std.error) %>%
mutate(beta_diff = beta_hat - beta_true) %>%
mutate(ci_l = beta_hat - qnorm(1 - alpha/ 2) * se_beta) %>%
mutate(ci_u = beta_hat + qnorm(1 - alpha/ 2) * se_beta) %>%
select(beta_hat, beta_diff, ci_l, ci_u, se_beta, coverage)
return (estims_df)
}
# We are given a df of x and y with n rows (for each iteration of the 475 n_sims)
extract_estim_boot <- function(simdata, beta_true, alpha) {
cl_boot <- makeCluster(4)  # Adjust based on available cores
registerDoParallel(cl_boot)
nboot = 1 # how many samples do we draw?
all_boot_estims <- foreach(b = 1:nboot, .combine = c, .packages = c("dplyr", "broom", "tidyverse")) %dopar% {
# Non-parametric bootstrap sample
indices <- sample(seq_len(nrow(simdata)), size = nrow(simdata), replace = TRUE)
boot_sample <- simdata[indices, , drop = FALSE]
# Fit linear model
model <- lm(y ~ x, data = boot_sample)
# Extract beta_treatment
beta_hat_wrapper <- tidy(model, conf.int = TRUE) %>%
filter(term == "x") %>%
rename(beta_hat = estimate) %>%
select(beta_hat)
# Return the estimate or NA if invalid
if (nrow(beta_hat_wrapper) == 1) {
beta_hat_wrapper$beta_hat
} else {
NA
}
}
stopCluster(cl_boot)
print(all_boot_estims)
mean_beta_hat = mean(all_boot_estims, na.rm = TRUE) # bootstrapped beta_hat (mean of all beta_hats??? idk)
se_beta_hat = sd(all_boot_estims, na.rm = TRUE)/sqrt(length(all_boot_estims)) # do i just ignore the ses in the model. AM COnfused.
# Have nboot number of estimated beta hats
alpha = 0.05
#percentile_ci <- quantile(all_boot_estims, probs = c(alpha/2, 1-(alpha/2)))
tibble(
mean_beta_hat = mean_beta_hat,
se_beta_hat = se_beta_hat, # i think this is for intervals with bootstrap SE (Wald-type) so perhaps not what i want to do here
ci = 2,
)
}
library(tidyverse)
library(doParallel)
library(foreach)
library(dplyr)
library(here)
source(here("source", "utils.R"))
options(pillar.sigfig = 15)
# Ensure necessary directories exist
if (!dir.exists(here("results"))) {
dir.create(here("results"))
}
if (!dir.exists(here("results", "sim_wald"))) {
dir.create(here("results", "sim_wald"))
}
if (!dir.exists(here("results", "sim_boot"))) {
dir.create(here("results", "sim_boot"))
}
# Cluster setup
cl <- makeCluster(4)  # Use 8 cores
registerDoParallel(cl)
# Simulation setup
mc_err <- 0.01
cover <- 0.95
alpha <- 1 - 0.95
n_sim <- round((cover * (1 - cover)) / mc_err^2)  # Calculate number of simulations
n <- c(10, 50, 500)
beta_true <- c(0, 0.5, 2)
err_type <- c(0, 1)  # 1 = normal, 0 = right-skewed
param_grid <- expand.grid(
n = n,
beta_true = beta_true,
err_type = err_type
)
# Seeds for each loop
seeds <- floor(runif(n_sim, 1, 10000))
# Parallelized Wald results
wald_results <- foreach(
i = 1:nrow(param_grid),
.combine = rbind,  # Combine results across parameter combinations
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %dopar% {
params <- param_grid[i, ]
# Run simulations for n_sim in parallel
all_wald_estim <- foreach(
j = 1:n_sim,
.combine = rbind,  # Combine results for each simulation
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %do% {
set.seed(seeds[j])
simdata <- gen_data(n = params$n, beta_true = params$beta_true, err_type = params$err_type)
extract_estim_wald(simdata, params$beta_true, alpha)
}
# Save individual parameter combination results
filename <- paste0("scenario_", i, ".RDA")
save(all_wald_estim, file = here("results", "sim_wald", filename))
return(all_wald_estim)
}
save(wald_results, file = here("results", "sim_wald", "all_sim_wald_scenarios.RDA"))
# Parallelized Bootstrap results
boot_results <- foreach(
i = 1:nrow(param_grid),
.combine = rbind,  # Combine results across parameter combinations
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %dopar% {
params <- param_grid[i, ]
# Run simulations for n_sim in parallel
all_boot_percent_estim <- foreach(
j = 1:n_sim,
.combine = rbind,  # Combine results for each simulation
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %do% {
set.seed(seeds[j])
simdata <- gen_data(n = params$n, beta_true = params$beta_true, err_type = params$err_type)
extract_estim_boot(simdata, params$beta_true, alpha)
}
# Save individual parameter combination results
filename <- paste0("scenario_", i, ".RDA")
save(all_boot_percent_estim, file = here("results", "sim_boot", filename))
return(all_boot_percent_estim)
}
library(tidyverse)
library(doParallel)
library(foreach)
gen_data <- function(n, beta_true, err_type) {
beta0 <- 1
beta_treat <- beta_true
x <- rbinom(n, 1, prob = 0.5)
epsilon <- ifelse (err_type == 1, rnorm(n, mean = 0, sd = sqrt(2)), rlnorm(n, mean = 0, sd = sqrt(log(2))))
y = beta0 + beta_treat * x + epsilon
tibble(
x = x,
y = y
)
}
extract_estim_wald <- function(simdata, beta_true, alpha) {
x <- simdata$x
y <- simdata$y
model <- summary(lm(y ~ x))
estims_df <- tidy(model, conf.int = TRUE) %>%
filter(term == "x") %>%
mutate(coverage = ifelse(beta_true >= conf.low & beta_true <= conf.high, 1, 0)) %>%
rename(beta_hat = estimate) %>%
rename(se_beta = std.error) %>%
mutate(beta_diff = beta_hat - beta_true) %>%
mutate(ci_l = beta_hat - qnorm(1 - alpha/ 2) * se_beta) %>%
mutate(ci_u = beta_hat + qnorm(1 - alpha/ 2) * se_beta) %>%
select(beta_hat, beta_diff, ci_l, ci_u, se_beta, coverage)
return (estims_df)
}
# We are given a df of x and y with n rows (for each iteration of the 475 n_sims)
extract_estim_boot <- function(simdata, beta_true, alpha) {
nboot <- 1  # Number of bootstrap samples
all_boot_estims <- numeric(nboot)  # Preallocate a numeric vector
for (b in 1:nboot) {
# Non-parametric bootstrap sample
indices <- sample(seq_len(nrow(simdata)), size = nrow(simdata), replace = TRUE)
boot_sample <- simdata[indices, , drop = FALSE]
# Fit linear model
model <- lm(y ~ x, data = boot_sample)
# Extract beta_treatment
beta_hat_wrapper <- tidy(model, conf.int = TRUE) %>%
filter(term == "x") %>%
rename(beta_hat = estimate) %>%
select(beta_hat)
# Return the estimate or NA if invalid
if (nrow(beta_hat_wrapper) == 1) {
all_boot_estims[b] <- beta_hat_wrapper$beta_hat
} else {
all_boot_estims[b] <- NA
}
}
# Compute summary statistics
mean_beta_hat <- mean(all_boot_estims, na.rm = TRUE)  # Mean of bootstrap estimates
se_beta_hat <- sd(all_boot_estims, na.rm = TRUE) / sqrt(length(all_boot_estims))  # Standard error
# Percentile confidence interval
# Note: With nboot = 1, CI calculation isn't meaningful, but keeping for consistency
percentile_ci <- quantile(all_boot_estims, probs = c(alpha / 2, 1 - alpha / 2), na.rm = TRUE)
# Return results as a tibble
tibble(
mean_beta_hat = mean_beta_hat,
se_beta_hat = se_beta_hat,
ci_l = percentile_ci[1],  # Lower bound of CI
ci_u = percentile_ci[2]   # Upper bound of CI
)
}
library(tidyverse)
library(doParallel)
library(foreach)
library(dplyr)
library(here)
source(here("source", "utils.R"))
options(pillar.sigfig = 15)
# Ensure necessary directories exist
if (!dir.exists(here("results"))) {
dir.create(here("results"))
}
if (!dir.exists(here("results", "sim_wald"))) {
dir.create(here("results", "sim_wald"))
}
if (!dir.exists(here("results", "sim_boot"))) {
dir.create(here("results", "sim_boot"))
}
# Cluster setup
cl <- makeCluster(4)  # Use 8 cores
registerDoParallel(cl)
# Simulation setup
mc_err <- 0.01
cover <- 0.95
alpha <- 1 - 0.95
n_sim <- round((cover * (1 - cover)) / mc_err^2)  # Calculate number of simulations
n <- c(10, 50, 500)
beta_true <- c(0, 0.5, 2)
err_type <- c(0, 1)  # 1 = normal, 0 = right-skewed
param_grid <- expand.grid(
n = n,
beta_true = beta_true,
err_type = err_type
)
# Seeds for each loop
seeds <- floor(runif(n_sim, 1, 10000))
# Parallelized Wald results
wald_results <- foreach(
i = 1:nrow(param_grid),
.combine = rbind,  # Combine results across parameter combinations
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %dopar% {
params <- param_grid[i, ]
# Run simulations for n_sim in parallel
all_wald_estim <- foreach(
j = 1:n_sim,
.combine = rbind,  # Combine results for each simulation
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %do% {
set.seed(seeds[j])
simdata <- gen_data(n = params$n, beta_true = params$beta_true, err_type = params$err_type)
extract_estim_wald(simdata, params$beta_true, alpha)
}
# Save individual parameter combination results
filename <- paste0("scenario_", i, ".RDA")
save(all_wald_estim, file = here("results", "sim_wald", filename))
return(all_wald_estim)
}
save(wald_results, file = here("results", "sim_wald", "all_sim_wald_scenarios.RDA"))
# Parallelized Bootstrap results
boot_results <- foreach(
i = 1:nrow(param_grid),
.combine = rbind,  # Combine results across parameter combinations
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %dopar% {
params <- param_grid[i, ]
# Run simulations for n_sim in parallel
all_boot_percent_estim <- foreach(
j = 1:n_sim,
.combine = rbind,  # Combine results for each simulation
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %do% {
set.seed(seeds[j])
simdata <- gen_data(n = params$n, beta_true = params$beta_true, err_type = params$err_type)
extract_estim_boot(simdata, params$beta_true, alpha)
}
# Save individual parameter combination results
filename <- paste0("scenario_", i, ".RDA")
save(all_boot_percent_estim, file = here("results", "sim_boot", filename))
return(all_boot_percent_estim)
}
save(boot_results, file = here("results", "sim_boot", "all_sim_boot_scenarios.RDA"))
# Stop the parallel cluster
stopCluster(cl)
library(tidyverse)
library(doParallel)
library(foreach)
gen_data <- function(n, beta_true, err_type) {
beta0 <- 1
beta_treat <- beta_true
x <- rbinom(n, 1, prob = 0.5)
epsilon <- ifelse (err_type == 1, rnorm(n, mean = 0, sd = sqrt(2)), rlnorm(n, mean = 0, sd = sqrt(log(2))))
y = beta0 + beta_treat * x + epsilon
tibble(
x = x,
y = y
)
}
extract_estim_wald <- function(simdata, beta_true, alpha) {
x <- simdata$x
y <- simdata$y
model <- summary(lm(y ~ x))
estims_df <- tidy(model, conf.int = TRUE) %>%
filter(term == "x") %>%
mutate(coverage = ifelse(beta_true >= conf.low & beta_true <= conf.high, 1, 0)) %>%
rename(beta_hat = estimate) %>%
rename(se_beta = std.error) %>%
mutate(beta_diff = beta_hat - beta_true) %>%
mutate(ci_l = beta_hat - qnorm(1 - alpha/ 2) * se_beta) %>%
mutate(ci_u = beta_hat + qnorm(1 - alpha/ 2) * se_beta) %>%
select(beta_hat, beta_diff, ci_l, ci_u, se_beta, coverage)
return (estims_df)
}
# We are given a df of x and y with n rows (for each iteration of the 475 n_sims)
extract_estim_boot <- function(simdata, beta_true, alpha) {
nboot <- 100  # Number of bootstrap samples
all_boot_estims <- numeric(nboot)  # Preallocate a numeric vector
for (b in 1:nboot) {
# Non-parametric bootstrap sample
indices <- sample(seq_len(nrow(simdata)), size = nrow(simdata), replace = TRUE)
boot_sample <- simdata[indices, , drop = FALSE]
# Fit linear model
model <- lm(y ~ x, data = boot_sample)
# Extract beta_treatment
beta_hat_wrapper <- tidy(model, conf.int = TRUE) %>%
filter(term == "x") %>%
rename(beta_hat = estimate) %>%
select(beta_hat)
# Return the estimate or NA if invalid
if (nrow(beta_hat_wrapper) == 1) {
all_boot_estims[b] <- beta_hat_wrapper$beta_hat
} else {
all_boot_estims[b] <- NA
}
}
# Compute summary statistics
mean_beta_hat <- mean(all_boot_estims, na.rm = TRUE)  # Mean of bootstrap estimates
se_beta_hat <- sd(all_boot_estims, na.rm = TRUE) / sqrt(length(all_boot_estims))  # Standard error
# Percentile confidence interval
# Note: With nboot = 1, CI calculation isn't meaningful, but keeping for consistency
percentile_ci <- quantile(all_boot_estims, probs = c(alpha / 2, 1 - alpha / 2), na.rm = TRUE)
# Return results as a tibble
tibble(
mean_beta_hat = mean_beta_hat,
se_beta_hat = se_beta_hat,
ci_l = percentile_ci[1],  # Lower bound of CI
ci_u = percentile_ci[2]   # Upper bound of CI
)
}
library(tidyverse)
library(doParallel)
library(foreach)
library(dplyr)
library(here)
source(here("source", "utils.R"))
options(pillar.sigfig = 15)
# Ensure necessary directories exist
if (!dir.exists(here("results"))) {
dir.create(here("results"))
}
if (!dir.exists(here("results", "sim_wald"))) {
dir.create(here("results", "sim_wald"))
}
if (!dir.exists(here("results", "sim_boot"))) {
dir.create(here("results", "sim_boot"))
}
# Cluster setup
cl <- makeCluster(4)  # Use 8 cores
registerDoParallel(cl)
# Simulation setup
mc_err <- 0.01
cover <- 0.95
alpha <- 1 - 0.95
n_sim <- round((cover * (1 - cover)) / mc_err^2)  # Calculate number of simulations
n <- c(10, 50, 500)
beta_true <- c(0, 0.5, 2)
err_type <- c(0, 1)  # 1 = normal, 0 = right-skewed
param_grid <- expand.grid(
n = n,
beta_true = beta_true,
err_type = err_type
)
# Seeds for each loop
seeds <- floor(runif(n_sim, 1, 10000))
# Parallelized Wald results
wald_results <- foreach(
i = 1:nrow(param_grid),
.combine = rbind,  # Combine results across parameter combinations
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %dopar% {
params <- param_grid[i, ]
# Run simulations for n_sim in parallel
all_wald_estim <- foreach(
j = 1:n_sim,
.combine = rbind,  # Combine results for each simulation
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %do% {
set.seed(seeds[j])
simdata <- gen_data(n = params$n, beta_true = params$beta_true, err_type = params$err_type)
extract_estim_wald(simdata, params$beta_true, alpha)
}
# Save individual parameter combination results
filename <- paste0("scenario_", i, ".RDA")
save(all_wald_estim, file = here("results", "sim_wald", filename))
return(all_wald_estim)
}
save(wald_results, file = here("results", "sim_wald", "all_sim_wald_scenarios.RDA"))
# Parallelized Bootstrap results
boot_results <- foreach(
i = 1:nrow(param_grid),
.combine = rbind,  # Combine results across parameter combinations
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %dopar% {
params <- param_grid[i, ]
# Run simulations for n_sim in parallel
all_boot_percent_estim <- foreach(
j = 1:n_sim,
.combine = rbind,  # Combine results for each simulation
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "doParallel", "foreach")
) %do% {
set.seed(seeds[j])
simdata <- gen_data(n = params$n, beta_true = params$beta_true, err_type = params$err_type)
extract_estim_boot(simdata, params$beta_true, alpha)
}
# Save individual parameter combination results
filename <- paste0("scenario_", i, ".RDA")
save(all_boot_percent_estim, file = here("results", "sim_boot", filename))
return(all_boot_percent_estim)
}
save(boot_results, file = here("results", "sim_boot", "all_sim_boot_scenarios.RDA"))
# Stop the parallel cluster
stopCluster(cl)
boot_results[[1]]
View(boot_results)
View(wald_results)
